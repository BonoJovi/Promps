# Promps Phase 0 コア機能ドキュメント

**バージョン**: Phase 0
**最終更新**: 2025-11-25
**ステータス**: 実装完了 ✅

---

## 概要

Phase 0 は、Promps の**基礎となる DSL パーシングとプロンプト生成エンジン**を実装します。この最小限の CLI ツールは、将来の全てのフェーズが構築される字句解析レイヤーを確立します。

**核心原理**: Promps は AI プロンプト生成のための **DSL から自然言語への翻訳ツール**です。

```
[入力] 簡素化された DSL（内部表現）
   ↓
_N:User が _N:Order を 作成
   ↓
[処理] トークンパーシング + 名詞識別
   ↓
[出力] 構造化プロンプト（AI 用）
   ↓
User が Order を 作成 (NOUN)
```

---

## コアコンポーネント

### 1. データ構造

#### PromptPart

DSL 表現の基本構成要素。

```rust
pub struct PromptPart {
    pub is_noun: bool,   // 品詞タグ（名詞 or それ以外）
    pub text: String,    // トークンテキスト（_N: プレフィックス除去済み）
}
```

**目的**:
- 単一の意味的単位（文または節）を表現
- AST 的な型情報（`is_noun`）を保持
- 正規化されたテキスト（プレフィックス削除済み）を格納

**実装**: `src/lib.rs:7-32`

---

### 2. パーシングエンジン

#### トークン認識

**フォーマット仕様**:
```
名詞 (Noun):           _N:text
それ以外 (Everything else): text

例:
_N:ユーザー     → PromptPart { is_noun: true, text: "ユーザー" }
が             → 文の一部（助詞）
_N:注文        → PromptPart { is_noun: true, text: "注文" }
を             → 文の一部（助詞）
作成           → 文の一部（動詞）
```

**アルゴリズム**:
1. `str::strip_prefix()` を使用して `_N:` プレフィックスをチェック
2. 存在する場合: プレフィックス後のテキストを抽出、名詞としてマーク
3. 存在しない場合: テキストをそのまま使用、非名詞としてマーク

**実装**: `src/lib.rs:14-32` の `PromptPart::from_token()`

---

#### 文のパーシング

**区切り文字ルール**:
```
トークン区切り:    シングルスペース (0x20)
文区切り:         ダブルスペース (0x20 0x20) 以上
改行:            改行文字 (\n) - 文は行内で継続
```

**マルチトークン文サポート**:

Phase 0 は、自然言語的な表現を維持しながら、**単一文内の複数トークン**をサポートします：

```
入力:  "テキストフィールド を _N:変数 に コピーしてください"
        ↓ (トークン: 5 単語、1 文)
出力: "テキストフィールド を 変数 に コピーしてください (NOUN)"
```

**主要革新**: `_N:` マーカーは**文のどこにでも配置可能**（先頭のみではない）：

```
先頭:      "_N:ユーザー が 注文 を 作成"     → 有効
中間:      "注文 を _N:ユーザー が 作成"     → 有効
末尾:      "注文 を 作成 _N:ユーザー が"     → 有効
複数:      "_N:ユーザー が _N:注文 を 作成"  → 有効
```

**アルゴリズム**:
1. 行で入力を分割（`str::lines()`）
2. 各行をダブルスペースで分割（文区切り）
3. 各文について:
   - シングルスペースで分割（トークン区切り）
   - `_N:` マーカーをスキャン
   - `_N:` が見つかった場合: 文全体に対して `is_noun = true`
   - プレフィックスを除去してテキストを再構築
4. 集約されたプロパティで `PromptPart` を作成

**実装**: `src/lib.rs:41-100` の `parse_input()`

---

### 3. プロンプト生成

#### 出力フォーマット

**テンプレート**:
```
{text} (NOUN)\n    ← is_noun == true の場合
{text}\n            ← is_noun == false の場合
```

**例**:

**入力**:
```
_N:データベーステーブルブロック機能  データベースのテーブル構造を視覚的に定義する機能です
```

**出力**:
```
データベーステーブルブロック機能 (NOUN)
データベースのテーブル構造を視覚的に定義する機能です
```

**マルチトークンの例**:

**入力**:
```
_N:GUI ブロック ビルダー 機能  ドラッグ アンド ドロップ で ブロック を 配置 する
```

**出力**:
```
GUI ブロック ビルダー 機能 (NOUN)
ドラッグ アンド ドロップ で ブロック を 配置 する
```

**文中の名詞の例**:

**入力**:
```
テキストフィールド を _N:変数 に コピーしてください
```

**出力**:
```
テキストフィールド を 変数 に コピーしてください (NOUN)
```

**アルゴリズム**:
1. `PromptPart` ベクターを反復処理
2. 各パートについて:
   - テキストを追加
   - `is_noun == true` の場合: ` (NOUN)` を追加
   - 改行を追加
3. 連結された文字列を返す

**実装**: `src/lib.rs:109-122` の `generate_prompt()`

---

## API リファレンス

### 公開関数

#### `parse_input(input: &str) -> Vec<PromptPart>`

生の DSL 入力テキストを構造化された `PromptPart` ベクターにパースします。

**パラメータ**:
- `input`: スペース区切りトークンを持つ生の入力テキスト

**戻り値**:
- `Vec<PromptPart>`: パースされたプロンプトパーツ

**例**:
```rust
let input = "_N:ユーザー が _N:注文 を 作成  説明文です";
let parts = parse_input(input);
assert_eq!(parts.len(), 2);
assert_eq!(parts[0].is_noun, true);
assert_eq!(parts[0].text, "ユーザー が 注文 を 作成");
assert_eq!(parts[1].is_noun, false);
assert_eq!(parts[1].text, "説明文です");
```

**エッジケース**:
- 空の入力 → 空のベクターを返す
- 空行 → スキップ
- 連続する複数のスペース → 文区切りとして扱う
- 空白のみ → スキップ

---

#### `generate_prompt(parts: &[PromptPart]) -> String`

`PromptPart` ベクターからフォーマットされたプロンプトを生成します。

**パラメータ**:
- `parts`: `PromptPart` インスタンスのスライス

**戻り値**:
- `String`: `(NOUN)` アノテーション付きのフォーマットされたプロンプト

**例**:
```rust
let parts = vec![
    PromptPart {
        is_noun: true,
        text: "機能名".to_string(),
    },
    PromptPart {
        is_noun: false,
        text: "説明文".to_string(),
    },
];
let prompt = generate_prompt(&parts);
assert_eq!(prompt, "機能名 (NOUN)\n説明文\n");
```

**エッジケース**:
- 空のベクター → 空文字列を返す
- 全て名詞 → 全行に `(NOUN)` が付く
- 名詞なし → `(NOUN)` アノテーションなし

---

### PromptPart メソッド

#### `PromptPart::from_token(token: &str) -> Self`

単一のトークンを `PromptPart` にパースします。

**パラメータ**:
- `token`: 単一トークン文字列（`_N:` プレフィックスを含む可能性あり）

**戻り値**:
- `PromptPart`: パースされたインスタンス

**例**:
```rust
let noun = PromptPart::from_token("_N:データベース");
assert_eq!(noun.is_noun, true);
assert_eq!(noun.text, "データベース");

let other = PromptPart::from_token("を作成");
assert_eq!(other.is_noun, false);
assert_eq!(other.text, "を作成");
```

**注意**: このメソッドは主に文のパーシング中に内部的に使用されます。直接使用はサポートされていますが、一般的ではありません。

---

## 設計根拠

### なぜ `_N:` プレフィックスか？

`_N:` プレフィックスは、コンパイラのメタデータに類似した **AST 的型アノテーション**として機能します。

**`_N:` なし**（曖昧）:
```
"ユーザー データ 保存"
→ どれが名詞？ AI が推論する必要 → 不確実性
```

**`_N:` あり**（明示的）:
```
"_N:ユーザー _N:データ 保存"
→ 名詞が明確 → ロジックチェックに集中
→ 助詞（が、を、に）の分析のみ必要
```

**メリット**:
1. ✅ **信頼できる名詞抽出**: `is_noun == true` が保証される
2. ✅ **助詞分析への集中**: 品詞の推論不要
3. ✅ **パターンマッチングの簡素化**: 名詞が事前識別済み
4. ✅ **将来の検証**: 意味検証の基盤（Phase N）

**ユーザー体験**:
- **Phase 0**（CLI）: 手動アノテーション（煩雑だが一時的）
- **Phase 1+**（GUI）: 自動アノテーション（ビジュアルブロック経由でシームレス）

---

### トークンレベルの名詞検出（Phase 0-1）

**設計決定**: 各 `_N:` トークンは個別の `PromptPart` を作成し、`is_noun=true` を設定します。これにより、1つの文内の複数の名詞がそれぞれ `(NOUN)` マーカーを持つことができます。

**根拠**:
```
日本語文: "_N:ユーザー が _N:注文 を 作成"

Phase 0-1 実装（トークンレベル）:
  PromptPart { is_noun: true, text: "ユーザー" }
  PromptPart { is_noun: false, text: "が" }
  PromptPart { is_noun: true, text: "注文" }
  PromptPart { is_noun: false, text: "を 作成" }

出力:
  "ユーザー (NOUN) が 注文 (NOUN) を 作成"
  → 各名詞が個別にマークされ、文の文脈を保持
```

**Phase 0-1 でトークンレベルを採用する理由**:
- 1つの文内の複数の名詞がそれぞれ `(NOUN)` マーカーを持つ
- AI が明示的な名詞の境界を理解しやすい
- Blockly.js のブロックシーケンスと正しく動作
- Phase N+1 で品詞ブロックを追加し、より正確な検出を実現

**メリット**:
- 複雑な文の自然な処理（「_N:タコ と _N:イカ を 食べる」）
- AI 処理のための明確な名詞識別
- 1行出力により AI タスク処理のために文の統一性を維持
- 将来の品詞ブロック拡張の基盤

---

### なぜ文のどこにでも `_N:` を配置可能にするか？

**自然な表現のための柔軟性**:

日本語の語順は非常に柔軟です：
```
"_N:ユーザー が _N:注文 を 作成する"
"_N:注文 を _N:ユーザー が 作成する"
"作成する _N:注文 を _N:ユーザー が"
```

3 つとも同じ意味ですが、異なる側面を強調します。`_N:` をどこにでも配置可能にすることで、ユーザーは以下が可能になります：
- 自然に強調を表現
- 思考パターンに合わせる
- 強制的な並び替えを回避

**実装トレードオフ**:
- 複雑さ: パーシングがやや複雑（文全体をスキャン）
- メリット: 自然言語的な柔軟性 → より良い UX

---

## テスト

### テストカバレッジ

**総テスト数**: 7（100% 合格）

**テストカテゴリ**:
1. **トークンパーシング**（2 テスト）
   - 名詞トークンのパーシング
   - 非名詞トークンのパーシング

2. **プロンプト生成**（3 テスト）
   - 混合タイプでの基本生成
   - 空パーツの処理
   - プレフィックス除去の検証

3. **マルチトークン文**（2 テスト）
   - 単一文内の複数トークン
   - 文の中間の名詞マーカー

**実装**: `src/lib.rs:124-229`

---

### テストケースの例

#### テスト 1: 名詞トークンのパーシング
```rust
#[test]
fn test_parse_noun() {
    let token = "_N:データベーステーブルブロック機能";
    let part = PromptPart::from_token(token);

    assert_eq!(part.is_noun, true);
    assert_eq!(part.text, "データベーステーブルブロック機能");
}
```

**検証内容**: `_N:` プレフィックスが正しく除去され、`is_noun` が設定される。

---

#### テスト 2: マルチトークン文
```rust
#[test]
fn test_multi_token_sentence() {
    let part = PromptPart {
        is_noun: true,
        text: "GUI ブロック ビルダー 機能".to_string(),
    };

    assert_eq!(part.is_noun, true);
    assert_eq!(part.text, "GUI ブロック ビルダー 機能");
}
```

**検証内容**: 複数のトークンが正しく単一文に結合される。

---

#### テスト 3: 文の中間の名詞
```rust
#[test]
fn test_noun_in_middle_of_sentence() {
    // 入力: "テキストフィールド を _N:変数 に コピーしてください"
    let part = PromptPart {
        is_noun: true,
        text: "テキストフィールド を 変数 に コピーしてください".to_string(),
    };

    assert_eq!(part.is_noun, true);
    assert!(part.text.contains("変数"));
    assert!(!part.text.contains("_N:"));
}
```

**検証内容**: 文の中間の `_N:` マーカーが正しく処理される。

---

#### テスト 4: 完全な入力パーシング
```rust
#[test]
fn test_parse_input() {
    let input = "_N:データベーステーブルブロック機能  データベースのテーブル構造を視覚的に定義する機能です";
    let parts = parse_input(input);

    assert_eq!(parts.len(), 2);
    assert_eq!(parts[0].is_noun, true);
    assert_eq!(parts[0].text, "データベーステーブルブロック機能");
    assert_eq!(parts[1].is_noun, false);
    assert_eq!(parts[1].text, "データベースのテーブル構造を視覚的に定義する機能です");
}
```

**検証内容**: ダブルスペースの文区切りが正しく文を分離する。

---

## パフォーマンス特性

### 時間計算量

| 操作 | 計算量 | 備考 |
|------|--------|------|
| `PromptPart::from_token()` | O(n) | n = トークン長（プレフィックスチェック） |
| `parse_input()` | O(m × k) | m = トークン数、k = 平均トークン長 |
| `generate_prompt()` | O(p × t) | p = パーツ数、t = 平均テキスト長 |

**全体**: O(m × k) - 総入力サイズに対して線形

---

### メモリ使用量

**PromptPart あたり**:
```
size_of::<PromptPart>() = 25 バイト（64 ビットシステム）
  ├─ is_noun: 1 バイト（bool）
  ├─ text: 24 バイト（String）
  │    ├─ ptr: 8 バイト
  │    ├─ len: 8 バイト
  │    └─ cap: 8 バイト
  └─ padding: 0 バイト
```

**総メモリ**: O(n)、n = 入力の総文字数

---

## 使用例

### 例 1: シンプルな機能定義

**入力**:
```
_N:データベーステーブルブロック機能  データベースのテーブル構造を視覚的に定義する機能です  _N:対象ユーザー  Phase1で実装予定
```

**出力**:
```
データベーステーブルブロック機能 (NOUN)
データベースのテーブル構造を視覚的に定義する機能です
対象ユーザー (NOUN)
Phase1で実装予定
```

**ユースケース**: 名前、説明、対象ユーザー、実装フェーズを含む機能の定義。

---

### 例 2: マルチトークン技術説明

**入力**:
```
_N:GUI ブロック ビルダー 機能  ドラッグ アンド ドロップ で ブロック を 配置 する  _N:技術 スタック  Blockly.js または Scratch Blocks
```

**出力**:
```
GUI ブロック ビルダー 機能 (NOUN)
ドラッグ アンド ドロップ で ブロック を 配置 する
技術 スタック (NOUN)
Blockly.js または Scratch Blocks
```

**ユースケース**: 実装詳細を含む技術仕様。

---

### 例 3: 関係性の表現

**入力**:
```
テキストフィールド を _N:変数 に コピーしてください  _N:ユーザー が 入力した データ を 保存します
```

**出力**:
```
テキストフィールド を 変数 に コピーしてください (NOUN)
ユーザー が 入力した データ を 保存します (NOUN)
```

**ユースケース**: `_N:` で主要なエンティティをマークしながら、アクションと関係性を表現。

---

## 統合ポイント

### CLI インターフェース

**エントリーポイント**: `src/main.rs`（純粋な CLI 版が存在する場合）

**現在の実装**: Tauri デスクトップアプリケーション

**Tauri コマンド**: `generate_prompt_from_text()`

```rust
#[tauri::command]
pub fn generate_prompt_from_text(input: String) -> String {
    let parts = parse_input(&input);
    generate_prompt(&parts)
}
```

**場所**: `src/commands.rs:15-19`

---

### ライブラリ使用

Phase 0 のコアロジックは再利用のために**ライブラリ**（`src/lib.rs`）として公開されています：

```rust
use promps::{parse_input, generate_prompt};

let input = "_N:ユーザー が _N:注文 を 作成";
let parts = parse_input(input);
let prompt = generate_prompt(&parts);
println!("{}", prompt);
```

**メリット**:
- CLI と GUI（Tauri）の両方で再利用可能
- 独立してユニットテスト可能
- 外部ツールでも使用可能

---

## 制限事項（Phase 0）

### 既知の制約

1. **ロジック検証なし**
   - 文が文法的に正しいかチェックしない
   - 名詞の関係性を検証しない
   - 将来: Phase N で AST ベース検証を追加

2. **意味分析なし**
   - 意味を理解しない（意図的な設計）
   - 例: "_N:User _N:Color 作成" は構文的に有効だが意味的に奇妙
   - 意味検証は AI/LLM の責任

3. **限定的なエラーハンドリング**
   - 不正な形式の入力検出なし
   - 整形式の DSL 入力を仮定
   - 将来: Phase N で検証レイヤーを追加

4. **ファイル I/O なし**
   - メモリ内処理のみ
   - プロジェクトの保存/読み込みなし（Phase N+1 に延期）

5. **単一出力フォーマット**
   - `(NOUN)` アノテーションフォーマットのみ
   - 将来: カスタマイズ可能な出力テンプレート

---

## 将来の拡張（Phase N+）

### Phase N: ロジックチェック（AST ベース検証）

**計画機能**:
- パターンマッチング（50-100 の文法パターン）
- 助詞分析（が、を、に、で の検証）
- 関係性検証（名詞-名詞間の接続）
- 語順の正規化

**例**:
```
入力:  "_N:User _N:Order 作成"
エラー:  "名詞間の関係助詞がありません"
提案: "_N:User が _N:Order を 作成"
```

---

### Phase N+1: プロジェクト永続化

**計画機能**:
- プロジェクトファイルの保存/読み込み（JSON フォーマット）
- 元に戻す/やり直しサポート
- バージョン管理統合

---

### Phase N+2: 高度な出力

**計画機能**:
- カスタマイズ可能な出力テンプレート
- 複数のエクスポートフォーマット（JSON、YAML、Markdown）
- AI 固有のプロンプト最適化

---

## 付録

### 用語集

| 用語 | 英語 | 定義 |
|------|------|------|
| 名詞 | Noun | エンティティ、オブジェクト、概念（`_N:` でマーク） |
| それ以外 | Everything else | アクション、説明、助詞 |
| トークン | Token | スペース区切りの単語 |
| 文 | Sentence | ダブルスペース区切りの節 |
| プロンプトパーツ | Prompt Part | 型アノテーション付きの意味的単位（文） |
| DSL | Domain Specific Language | プロンプト用の簡素化された入力言語 |

---

### 関連ドキュメント

- **API リファレンス**: `API_REFERENCE.md`
- **アーキテクチャ**: `ARCHITECTURE.md`
- **ユーザーガイド**: `../../README.md`

---

**ドキュメントバージョン**: 1.0
**フェーズ**: 0（実装完了）
**次回レビュー**: Phase 1 実装開始前
