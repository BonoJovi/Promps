# 規模とアーキテクチャの関係

**最終更新**: 2025-12-08

---

## はじめに

このドキュメントでは、**プロジェクトの規模とアーキテクチャパターンの選択**について説明します。

多くのシステム設計者が陥りやすい落とし穴は、**「成功したアーキテクチャパターンをすべてのプロジェクトに適用しようとすること」**です。

しかし、**アーキテクチャは道具であり、絶対法則ではありません**。プロジェクトの規模に応じて、適切なアーキテクチャパターンを選択する必要があります。

---

## Promps: 意図的なミニマル実装

### なぜPrompsはミニマルなのか

Prompsは**意図的に**ミニマルな実装を選択しています。

**よくある誤解**:
```
❌ 「時間がないから最小限の機能だけ」
❌ 「プロトタイプだから簡素化した」
❌ 「野心が足りない」
```

**実際の理由**:
```
✅ ミニマルだからこそ、純粋なレイヤードアーキテクチャが可能
✅ アーキテクチャの実験場として最適
✅ ドキュメント化しやすい
✅ 設計原則の証明として機能
✅ 参照実装として再利用可能
```

### Prompsの設計制約

```
目的: 単一（DSL → 自然言語変換）
Phase数: 有限（5-10個）
依存関係: 一方向（Phase N → Phase 0）
相互依存: 最小限
複雑性: 意図的に低い
```

### Unix哲学の実践

```
"Do one thing and do it well"
（1つのことをうまくやる）
  ↓
Prompsは1つのことだけをする: DSL → NL変換
  ↓
そしてうまくやる: 純粋なレイヤードアーキテクチャ
```

---

## KakeiBon: 必然的に複雑

### システムの特徴

```
目的: 複数（ユーザー管理、取引記録、暗号化、レポート、i18n...）
機能: 10+画面
テーブル: 10+個
テスト: 525個
依存関係: 双方向（取引 ↔ 口座 ↔ カテゴリ）
複雑性: 本質的に高い
```

### なぜレイヤードアーキテクチャは適用できないか

もし、KakeiBonに厳密なレイヤードアーキテクチャを適用したら：

```
Phase 0: データベースアクセス
Phase 1: 暗号化レイヤー
Phase 2: ユーザー管理
Phase 3: 口座管理
Phase 4: カテゴリ管理
Phase 5: 取引管理
Phase 6: 集計機能
Phase 7: UIレイヤー
...
Phase 15-20: ???

問題点:
❌ Phase数が多すぎる（管理不可能）
❌ 相互依存が複雑（循環依存が避けられない）
❌ feature branchが爆発（15-20個の永続ブランチ）
❌ API安定性が不可能（すべてがすべてに依存）
```

### KakeiBonが実際に使った手法

レイヤードアーキテクチャの代わりに：

- **モジュール化**（レイヤー化ではない）
- **戦略的共通化**
- **SQL集約化**
- **定数の外部化**
- **従来のGit Flow**（feature branchはマージ後削除）

---

## 規模とアーキテクチャの対応表

| 規模 | Phase数 | アーキテクチャ | ブランチ戦略 | 例 |
|------|---------|---------------|-------------|-----|
| **小規模** | 5-10 | 純粋なレイヤード | Persistent Feature Branch | Promps |
| **中規模** | 10-20 | ハイブリッド（レイヤード + モジュラー） | 改良版Git Flow | - |
| **大規模** | 20+ | マイクロサービス / モジュラー | Feature Flag / Trunk-based | KakeiBon |

---

## レイヤードアーキテクチャが機能する条件

### 理想的な条件

✅ **目的が単一**
- 例: Promps（DSL変換のみ）

✅ **レイヤー数が有限**（< 10個）
- 事前にすべてのPhaseを列挙できる

✅ **レイヤー境界が明確**
- 各Phaseが明確な責務を持つ

✅ **依存関係が一方向**
- 上位レイヤーは下位レイヤーのみに依存

✅ **相互依存が最小限**
- レイヤー間で横方向の通信が不要

✅ **コアレイヤーが安定**
- Phase 0のAPIが不変を保てる

### 条件を満たした場合のメリット

- 粗結合（自動的に発生）
- 簡単なモジュール分離
- Persistent Feature Branchが機能
- API安定性ポリシーが実践可能
- マージコンフリクトが稀

---

## レイヤードアーキテクチャが失敗する場合

### 警告サイン

❌ **複数の競合する目的**
- 例: 「ユーザー管理とレポートと暗号化と...」

❌ **レイヤー数が不明確**
- 「開発しながらレイヤーを決めよう」

❌ **曖昧な境界**
- 「この機能はPhase 3かPhase 5か...」

❌ **循環依存**
- 取引がカテゴリを必要とし、カテゴリが取引を必要とする

❌ **多数の相互依存**
- すべての機能が5つ以上の他機能に触れる

❌ **不安定なコア**
- Phase 0のAPIを頻繁に変更する必要がある

### 何が起こるか

- 密結合が発生
- モジュール分離が困難
- Persistent Branchが負担になる
- API安定性が不可能
- マージコンフリクトが頻発

### 代替アプローチ

**中規模プロジェクト向け**:
- モジュラーアーキテクチャ（レイヤードではない）
- サービス志向アーキテクチャ
- プラグインアーキテクチャ

**大規模プロジェクト向け**:
- マイクロサービス
- Feature Flag
- Trunk-based開発

---

## KakeiBon → Promps の知見継承

### KakeiBonで学んだこと（実践）

```
暗黙的に発見されたパターン:
- モジュール化が有効
- 共通化が重要
- SQL集約化で認知負荷軽減
- 定数外部化で明確性向上
- 即時テストで問題早期発見
```

### Prompsで形式化したこと（理論）

```
明示的に抽出された原則:
- レイヤードアーキテクチャ（規模が許す場合）
- Non-Breaking Extension Principle
- API安定性ポリシー
- Persistent Feature Branch戦略
- 創発的な粗結合
```

### 相補的な関係

```
KakeiBon（複雑系）
  ↓ 実践からパターン抽出
Promps（単純系）
  ↓ 設計原則として形式化
.ai-context/（ドキュメント化）
  ↓ 再利用可能な知識
未来のプロジェクト
```

**両方があってこそ**:
- KakeiBonだけ → 「うまくいったけど、なぜ？」
- Prompsだけ → 「良い理論だけど、実際は？」
- **両方** → 実践 ↔ 理論の統合

---

## このアプローチのスケーラビリティ限界

### Prompsアプローチが機能する条件

```
Phase数: 5-10個（管理可能）
Feature Branch: 5-10個（追跡可能）
開発者: 1-3人（調整が容易）
目的: 単一（境界が明確）
```

### 破綻する条件

```
Phase数: 15-20+個（圧倒的）
Feature Branch: 15-20+個（混乱）
開発者: 10+人（調整が困難）
目的: 複数（境界が曖昧）
```

---

## よくある設計ミス

### ミス1: 成功パターンの盲目的適用

**間違った思考**:
```
「Prompsでレイヤードアーキテクチャが成功した」
  ↓
「すべてのプロジェクトでレイヤードアーキテクチャを使おう」
  ↓
大規模プロジェクトで失敗
```

**正しい思考**:
```
「Prompsでレイヤードアーキテクチャが成功した」
  ↓
「なぜ成功したか？→ ミニマルだから」
  ↓
「次のプロジェクトの規模は？」
  ↓
規模に応じたアーキテクチャを選択
```

### ミス2: 過剰な一般化

**間違った思考**:
```
「この原則はすべてのケースに適用できるはず」
  ↓
規模を無視した適用
  ↓
失敗
```

**正しい思考**:
```
「この原則はどの条件で機能するか？」
  ↓
条件を明確化
  ↓
条件を満たすプロジェクトにのみ適用
```

### ミス3: ミニマル実装の軽視

**間違った思考**:
```
「ミニマル実装 = 機能が少ない = 価値が低い」
```

**正しい理解**:
```
「ミニマル実装 = 本質の抽出 = アーキテクチャの実験場」
  ↓
設計原則の検証に最適
  ↓
将来のプロジェクトへの指針
```

---

## 意思決定フレームワーク

新しいプロジェクトを始める際、以下の質問に答えてください：

### 質問1: 目的はいくつありますか？

- **単一** → レイヤードアーキテクチャを検討
- **複数** → モジュラーアーキテクチャを検討

### 質問2: すべてのPhaseを事前に列挙できますか？

- **はい、10個未満** → レイヤードが機能するかも
- **いいえ、または10個以上** → モジュラーが安全

### 質問3: 依存関係は一方向ですか？

- **ほぼ一方向** → レイヤードが機能するかも
- **いいえ（循環依存）** → モジュラーが安全

### 質問4: コアは安定していますか？

- **はい** → API安定性ポリシーが機能
- **いいえ** → バージョニング/非推奨化を使用

### 質問5: 開発者は何人ですか？

- **1-3人** → Persistent Branchが機能
- **10+人** → 従来のGit Flow

---

## 実例: 判断の実践

### 例1: 小規模プロジェクト（TODOアプリ）

```
目的: 単一（タスク管理）
Phase数: 5個程度（UI、ストレージ、検索、フィルター、通知）
依存関係: 一方向
開発者: 1-2人

判断: レイヤードアーキテクチャ ✅
```

### 例2: 中規模プロジェクト（ブログシステム）

```
目的: 複数（記事管理、ユーザー管理、コメント、検索、SEO）
Phase数: 12個程度
依存関係: 一部循環
開発者: 5人

判断: ハイブリッド（モジュラー + 一部レイヤード） ⚠️
```

### 例3: 大規模プロジェクト（ECサイト）

```
目的: 多数（商品、在庫、注文、決済、配送、顧客管理、レビュー...）
Phase数: 20+個
依存関係: 複雑に絡み合う
開発者: 20+人

判断: マイクロサービス / Feature Flag ❌ レイヤードは不適
```

---

## 核心的洞察

### 1. ミニマル ≠ 些末

```
Prompsは意図的にミニマル:
❌ おもちゃプロジェクトだから
✅ ミニマルさがアーキテクチャの純粋性を可能にするから
```

### 2. 規模が戦略を決定する

```
同じ原則、異なる実装:
- 小規模: 純粋なレイヤードアーキテクチャ
- 大規模: モジュラーアーキテクチャ

共通: 共通化、テスト、明確な境界
```

### 3. アーキテクチャは文脈依存

```
普遍的な「最良のアーキテクチャ」は存在しない
  ↓
最良のアーキテクチャ = 文脈に最も適合したもの
  ↓
文脈 = 規模 + 目的 + チーム + 制約
```

### 4. 実験にはシンプルさが必要

```
複雑系（KakeiBon）:
- 原則の分離が困難
- 多数の交絡因子

単純系（Promps）:
- 原則の検証が容易
- 因果関係が明確
  ↓
Prompsはアーキテクチャの実験室として機能
```

---

## 実践的ガイダンス

### 新規プロジェクト開始時

#### ステップ1: 規模を評価

```
Phase数を見積もる:
- < 10個 → レイヤードを検討
- > 10個 → モジュラーを検討
```

#### ステップ2: 依存関係をチェック

```
依存関係グラフを描く:
- ほぼ一方向 → レイヤードが機能
- 多数の循環 → モジュラーが安全
```

#### ステップ3: チームを評価

```
開発者数:
- 小チーム（1-3人） → Persistent Branch OK
- 大チーム（10+人） → 従来のGit Flow
```

#### ステップ4: ミニマルから開始

```
コアのみ実装
  ↓
アーキテクチャが機能するか検証
  ↓
その後拡張
```

---

## 設計者への教訓

### 教訓1: 成功体験に固執しない

あるプロジェクトで成功したアーキテクチャが、別のプロジェクトでも成功するとは限りません。

**常に問うべき質問**:
- 「このアーキテクチャはなぜうまくいったか？」
- 「その条件は次のプロジェクトでも満たされるか？」

### 教訓2: 規模の違いを認識する

10倍の規模の差は、**量的な差**ではなく**質的な差**です。

```
10行のコード ≠ 100行のコード × 0.1
10機能のシステム ≠ 100機能のシステム × 0.1

規模が変われば、アプローチも変える
```

### 教訓3: ミニマル実装の価値

ミニマル実装は「手抜き」ではなく、「本質の抽出」です。

```
機能削減 → 複雑性削減 → 純粋なアーキテクチャが可能
  ↓
設計原則の検証
  ↓
将来のプロジェクトへの指針
```

---

## まとめ

### 重要なポイント

1. **アーキテクチャは道具であり、絶対法則ではない**
2. **プロジェクトの規模がアーキテクチャ戦略を決定する**
3. **ミニマル実装は、アーキテクチャの純粋性を可能にする**
4. **成功パターンを盲目的に適用しない**
5. **文脈（規模、目的、チーム）を常に考慮する**

### PromsとKakeiBonの教訓

```
Promps: レイヤードアーキテクチャの理想形を示す
KakeiBon: 実世界の複雑性での実践を示す

両方から学ぶ:
- Promps → 「原則」の理解
- KakeiBon → 「適用限界」の理解
  ↓
バランスの取れた設計判断
```

---

## 参考資料

### プロジェクト内ドキュメント

- **DESIGN_PHILOSOPHY.md**: Promps固有の設計原則
- **BRANCHING_STRATEGY.md**: Persistent Feature Branch詳細
- **API_STABILITY.md**: API安定性ポリシー

### AI向けドキュメント

このドキュメントのAI向け版（簡潔なルールベース）は以下にあります：

- `.ai-context/core/SCALE_AND_ARCHITECTURE.md`

---

**質問やフィードバックがあれば、GitHubのIssueで気軽にお知らせください！**

---

**最終更新**: 2025-12-08
