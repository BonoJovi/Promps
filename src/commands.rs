/// Tauri Commands for Promps
///
/// This module defines all Tauri commands that bridge the frontend (JS)
/// and backend (Rust) logic.

use promps::{parse_input, generate_prompt};

/// Generate prompt from DSL input text
///
/// # Arguments
/// * `input` - Raw DSL text (with _N: markers, space-delimited)
///
/// # Returns
/// Formatted prompt string
#[tauri::command]
pub fn generate_prompt_from_text(input: String) -> String {
    let parts = parse_input(&input);
    generate_prompt(&parts)
}

/// Health check command
///
/// Simple command to verify Tauri communication is working
#[tauri::command]
pub fn greet(name: String) -> String {
    format!("Hello, {}! Welcome to Promps.", name)
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_generate_prompt_from_text() {
        let input = "_N:ユーザー が _N:注文 を 作成".to_string();
        let result = generate_prompt_from_text(input);

        // Each noun gets its own (NOUN) marker
        assert!(result.contains("ユーザー (NOUN)"));
        assert!(result.contains("注文 (NOUN)"));
        assert!(result.contains("が"));
        assert!(result.contains("を 作成"));
    }

    #[test]
    fn test_greet() {
        let result = greet("World".to_string());
        assert_eq!(result, "Hello, World! Welcome to Promps.");
    }

    // Phase 1 Integration Tests

    #[test]
    fn test_single_noun_block() {
        let input = "_N:User".to_string();
        let result = generate_prompt_from_text(input);

        assert!(result.contains("User"));
        assert!(result.contains("(NOUN)"));
    }

    #[test]
    fn test_multiple_noun_blocks() {
        // Phase 0-1: token-level is_noun detection
        // Each _N: token gets its own (NOUN) marker
        let input = "_N:User _N:Order".to_string();
        let result = generate_prompt_from_text(input);

        assert!(result.contains("User"));
        assert!(result.contains("Order"));
        // Each noun gets its own marker
        let noun_count = result.matches("(NOUN)").count();
        assert_eq!(noun_count, 2);
    }

    #[test]
    fn test_japanese_noun_blocks() {
        // Phase 0-1: token-level is_noun detection
        let input = "_N:データベース _N:テーブル _N:ブロック".to_string();
        let result = generate_prompt_from_text(input);

        assert!(result.contains("データベース"));
        assert!(result.contains("テーブル"));
        assert!(result.contains("ブロック"));
        // Each noun gets its own marker
        let noun_count = result.matches("(NOUN)").count();
        assert_eq!(noun_count, 3);
    }

    #[test]
    fn test_empty_input() {
        let input = "".to_string();
        let result = generate_prompt_from_text(input);

        assert_eq!(result, "");
    }

    #[test]
    fn test_whitespace_only_input() {
        let input = "   ".to_string();
        let result = generate_prompt_from_text(input);

        // Empty parts should result in empty output
        assert_eq!(result, "");
    }

    #[test]
    fn test_complex_sentence_structure() {
        // Note: _N: only applies to the token immediately after it
        let input = "_N:GUI ブロック ビルダー 機能  ドラッグ アンド ドロップ で ブロック を 配置 する".to_string();
        let result = generate_prompt_from_text(input);

        // Only "GUI" is marked as noun
        assert!(result.contains("GUI (NOUN)"));

        // Rest of the tokens are not nouns
        assert!(result.contains("ブロック ビルダー 機能"));
        assert!(result.contains("ドラッグ アンド ドロップ で ブロック を 配置 する"));
    }

    #[test]
    fn test_noun_and_description_alternating() {
        let input = "_N:機能  説明文  _N:対象ユーザー  開発者向け".to_string();
        let result = generate_prompt_from_text(input);

        // Nouns should be marked
        assert!(result.contains("機能"));
        assert!(result.contains("対象ユーザー"));

        // Descriptions should be present
        assert!(result.contains("説明文"));
        assert!(result.contains("開発者向け"));

        // Should have exactly 2 noun markers
        let noun_count = result.matches("(NOUN)").count();
        assert_eq!(noun_count, 2);
    }

    #[test]
    fn test_blockly_generated_code_pattern() {
        // Simulate code generated by Blockly.js workspace
        // Phase 0-1: token-level is_noun detection
        let input = "_N:User _N:Order _N:Product ".to_string();
        let result = generate_prompt_from_text(input);

        // All three nouns should be present
        assert!(result.contains("User"));
        assert!(result.contains("Order"));
        assert!(result.contains("Product"));

        // Each noun gets its own marker
        let noun_count = result.matches("(NOUN)").count();
        assert_eq!(noun_count, 3);
    }

    #[test]
    fn test_special_characters_in_noun() {
        let input = "_N:User123 _N:Order_ID".to_string();
        let result = generate_prompt_from_text(input);

        assert!(result.contains("User123"));
        assert!(result.contains("Order_ID"));
    }

    #[test]
    fn test_greet_with_empty_name() {
        let result = greet("".to_string());
        assert_eq!(result, "Hello, ! Welcome to Promps.");
    }

    #[test]
    fn test_greet_with_japanese_name() {
        let result = greet("太郎".to_string());
        assert_eq!(result, "Hello, 太郎! Welcome to Promps.");
    }
}
